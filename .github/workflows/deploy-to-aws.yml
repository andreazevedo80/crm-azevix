name: Deploy to AWS EC2

on:
  push:
    branches-ignore:
      - main
  pull_request:
    branches-ignore:
      - main

env:
  AWS_REGION: us-east-1
  INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
  GITHUB_REPOSITORY: andreazevedo80/crm-azevix

# Configuração de permissões necessárias para OIDC
permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials using OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Verify AWS connection
      run: |
        aws sts get-caller-identity
        echo "✅ AWS connection successful"

    - name: Check SSM Agent status
      run: |
        echo "Checking SSM Agent status..."
        aws ssm describe-instance-information \
          --filters "Key=InstanceIds,Values=${{ env.INSTANCE_ID }}" \
          --query 'InstanceInformationList[0].[InstanceId,PingStatus,LastPingDateTime]' \
          --output table

    - name: Deploy to EC2 using SSM
      run: |
        echo "Starting deployment via SSM..."
        
        # Executa o script de deploy via SSM
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ env.INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[
            'sudo -u ubuntu /home/ubuntu/deploy.sh https://github.com/${{ env.GITHUB_REPOSITORY }}.git ${{ github.ref_name }}'
          ]" \
          --timeout-seconds 600 \
          --query 'Command.CommandId' \
          --output text)
        
        echo "Command ID: $COMMAND_ID"
        
        # Aguarda a conclusão do comando
        echo "Waiting for command to complete..."
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ env.INSTANCE_ID }}"
        
        # Verifica o status do comando
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ env.INSTANCE_ID }}" \
          --query 'Status' \
          --output text)
        
        echo "Command Status: $STATUS"
        
        # Mostra os logs da execução
        echo "=== COMMAND OUTPUT ==="
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ env.INSTANCE_ID }}" \
          --query 'StandardOutputContent' \
          --output text
        
        echo "=== COMMAND ERRORS ==="
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ env.INSTANCE_ID }}" \
          --query 'StandardErrorContent' \
          --output text
        
        # Falha se o comando não foi bem-sucedido
        if [ "$STATUS" != "Success" ]; then
          echo "❌ Deployment failed with status: $STATUS"
          exit 1
        fi

    - name: Verify deployment
      run: |
        echo "Verifying deployment..."
        
        # Obtém o IP público da instância
        PUBLIC_IP=$(aws ec2 describe-instances \
          --instance-ids "${{ env.INSTANCE_ID }}" \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "Instance Public IP: $PUBLIC_IP"
        echo "Application URL: http://$PUBLIC_IP"
        
        # Teste simples de conectividade
        echo "Testing connectivity..."
        for i in {1..10}; do
          if curl -f "http://$PUBLIC_IP" --connect-timeout 5 --max-time 10; then
            echo "✅ Application is responding!"
            break
          else
            echo "⏳ Attempt $i/10: Application not ready yet, waiting..."
            sleep 10
          fi
        done

    - name: Get deployment logs
      if: always()
      run: |
        echo "=== DEPLOYMENT LOGS ==="
        aws ssm send-command \
          --instance-ids "${{ env.INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["tail -n 100 /var/log/deploy.log"]' \
          --query 'Command.CommandId' \
          --output text | \
        xargs -I {} aws ssm wait command-executed --command-id {} --instance-id "${{ env.INSTANCE_ID }}" && \
        aws ssm get-command-invocation \
          --command-id $(aws ssm send-command \
            --instance-ids "${{ env.INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["tail -n 100 /var/log/deploy.log"]' \
            --query 'Command.CommandId' \
            --output text) \
          --instance-id "${{ env.INSTANCE_ID }}" \
          --query 'StandardOutputContent' \
          --output text

    - name: Notify deployment status
      if: always()
      run: |
        PUBLIC_IP=$(aws ec2 describe-instances \
          --instance-ids "${{ env.INSTANCE_ID }}" \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        if [ ${{ job.status }} == 'success' ]; then
          echo "✅ Deployment successful!"
          echo "Branch: ${{ github.ref_name }}"
          echo "URL: http://$PUBLIC_IP"
        else
          echo "❌ Deployment failed!"
          echo "Check the logs above for details"
        fi