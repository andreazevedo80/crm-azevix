name: Deploy to AWS EC2

on:
  push:
    branches-ignore:
      - main
  pull_request:
    branches-ignore:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
  # Adicione o ARN da sua Role como uma vari√°vel de ambiente ou use o secret diretamente
  AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}

# Configura√ß√£o de permiss√µes necess√°rias para OIDC
permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ env.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Verify AWS connection
      run: |
        aws sts get-caller-identity
        echo "‚úÖ AWS connection successful"
    - name: Deploy and Monitor via SSM
      run: |
        echo "üöÄ Starting deployment of branch '${{ github.ref_name }}'..."

        # 1. Define o script de deploy em uma vari√°vel
        #    O conte√∫do do script continua o mesmo.
        DEPLOY_SCRIPT=$(cat <<'EOF'
        #!/bin/bash
        # Habilita o modo de depura√ß√£o para ver cada comando executado
        set -ex

        # Vari√°veis
        REPO_URL="https://github.com/andreazevedo80/crm-azevix.git"
        BRANCH="${{ github.ref_name }}"
        LOG_FILE="/tmp/deploy_log.txt"

        echo "--- Starting deployment at $(date) ---" > "$LOG_FILE"
        
        cd /home/ubuntu/projects

        if [ -d "crm-azevix" ]; then
          echo "Removing old project directory..."
          rm -rf crm-azevix
        fi

        echo "Cloning branch '$BRANCH' from '$REPO_URL'..."
        git clone --depth 1 -b "$BRANCH" "$REPO_URL" crm-azevix
        
        cd crm-azevix

        echo "Stopping old containers..." | tee -a "$LOG_FILE"
        docker-compose down --rmi all -v --remove-orphans || true
        
        echo "Pruning Docker system..." | tee -a "$LOG_FILE"
        docker system prune -af || true

        echo "Building and starting new containers..." | tee -a "$LOG_FILE"
        docker-compose up --build -d

        echo "--- Deployment completed at $(date) ---" | tee -a "$LOG_FILE"
        
        docker-compose ps
        EOF
        )

        # 2. Codifica o script em Base64 para envio seguro
        DEPLOY_SCRIPT_B64=$(echo "$DEPLOY_SCRIPT" | base64 -w 0)

        # 3. Define o comando que ser√° executado na inst√¢ncia: decodificar e rodar
        COMMAND_TO_RUN="echo $DEPLOY_SCRIPT_B64 | base64 --decode | /bin/bash"

        # 4. Envia o comando simples e seguro para o SSM
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ env.INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --comment "Deploying ${{ github.ref_name }}" \
          --parameters "commands=['$COMMAND_TO_RUN']" \
          --timeout-seconds 600 \
          --query "Command.CommandId" \
          --output text)
        
        echo "SSM Command sent with ID: $COMMAND_ID"
        echo "Waiting for deployment to complete..."
        
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ env.INSTANCE_ID }}"

        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ env.INSTANCE_ID }}" \
          --query "Status" \
          --output text)
        
        echo "‚úÖ Deployment finished with status: $STATUS"

        echo "--- SCRIPT OUTPUT (STDOUT) ---"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ env.INSTANCE_ID }}" \
          --query "StandardOutputContent" \
          --output text
        
        echo "--- SCRIPT ERRORS (STDERR) ---"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ env.INSTANCE_ID }}" \
          --query "StandardErrorContent" \
          --output text

        if [ "$STATUS" != "Success" ]; then
          echo "‚ùå Deployment failed!"
          exit 1
        fi

    - name: Verify application endpoint
      if: success()
      run: |
        echo "Verifying application endpoint..."
        PUBLIC_IP=$(aws ec2 describe-instances \
          --instance-ids "${{ env.INSTANCE_ID }}" \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "Application URL: http://$PUBLIC_IP"
        
        # Tenta se conectar por at√© 2 minutos (12 * 10s)
        for i in {1..12}; do
          if curl -fs "http://$PUBLIC_IP" --connect-timeout 5; then
            echo "‚úÖ Application is responding!"
            exit 0
          fi
          echo "Attempt $i/12: Application not ready yet, waiting 10 seconds..."
          sleep 10
        done
        
        echo "‚ùå Application did not respond in time."
        exit 1