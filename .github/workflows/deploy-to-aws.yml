name: Deploy to AWS EC2

on:
  push:
    branches-ignore:
      - main
  pull_request:
    branches-ignore:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
  # Adicione o ARN da sua Role como uma vari√°vel de ambiente ou use o secret diretamente
  AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}

# Configura√ß√£o de permiss√µes necess√°rias para OIDC
permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ env.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Verify AWS connection
      run: |
        aws sts get-caller-identity
        echo "‚úÖ AWS connection successful"

    # Este √© o √∫nico passo necess√°rio para o deploy
    - name: Deploy and Monitor via SSM
      run: |
        echo "üöÄ Starting deployment of branch '${{ github.ref_name }}'..."

        # Define o script de deploy como uma vari√°vel shell para maior clareza
        read -r -d '' DEPLOY_SCRIPT <<'EOF'
        #!/bin/bash
        set -e
        set -x

        # Vari√°veis
        REPO_URL="https://github.com/andreazevedo80/crm-azevix.git"
        BRANCH="${{ github.ref_name }}"
        LOG_FILE="/tmp/deploy_log.txt"

        echo "--- Starting deployment at $(date) ---" > "$LOG_FILE"
        
        # Navega para o diret√≥rio de projetos
        cd /home/ubuntu/projects

        # Remove diret√≥rio antigo, se existir
        if [ -d "crm-azevix" ]; then
          echo "Removing old project directory..."
          rm -rf crm-azevix
        fi

        # Clona a branch espec√≠fica do reposit√≥rio
        echo "Cloning branch '$BRANCH' from '$REPO_URL'..."
        git clone --depth 1 -b "$BRANCH" "$REPO_URL" crm-azevix
        
        # Entra no diret√≥rio do projeto
        cd crm-azevix

        echo "Stopping old containers..." | tee -a "$LOG_FILE"
        docker-compose down --rmi all -v --remove-orphans || true
        
        echo "Pruning Docker system..." | tee -a "$LOG_FILE"
        docker system prune -af || true

        echo "Building and starting new containers..." | tee -a "$LOG_FILE"
        docker-compose up --build -d

        echo "--- Deployment completed at $(date) ---" | tee -a "$LOG_FILE"
        
        # Mostra o status final
        docker-compose ps
        EOF

        # Envia o script para execu√ß√£o via SSM
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ env.INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --comment "Deploying ${{ github.ref_name }} to crm-azevix" \
          --parameters "commands=[$DEPLOY_SCRIPT]" \
          --timeout-seconds 600 \
          --query "Command.CommandId" \
          --output text)
        
        echo "SSM Command sent with ID: $COMMAND_ID"
        echo "Waiting for deployment to complete..."
        
        # Aguarda a conclus√£o do comando
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ env.INSTANCE_ID }}"

        # Obt√©m o status final da execu√ß√£o
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ env.INSTANCE_ID }}" \
          --query "Status" \
          --output text)
        
        echo "‚úÖ Deployment finished with status: $STATUS"

        # Exibe a sa√≠da padr√£o (logs) do script
        echo "--- SCRIPT OUTPUT (STDOUT) ---"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ env.INSTANCE_ID }}" \
          --query "StandardOutputContent" \
          --output text
        
        # Exibe a sa√≠da de erro, se houver
        echo "--- SCRIPT ERRORS (STDERR) ---"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ env.INSTANCE_ID }}" \
          --query "StandardErrorContent" \
          --output text

        # Falha o workflow se o comando SSM n√£o foi bem-sucedido
        if [ "$STATUS" != "Success" ]; then
          echo "‚ùå Deployment failed!"
          exit 1
        fi

    - name: Verify application endpoint
      if: success()
      run: |
        echo "Verifying application endpoint..."
        PUBLIC_IP=$(aws ec2 describe-instances \
          --instance-ids "${{ env.INSTANCE_ID }}" \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "Application URL: http://$PUBLIC_IP"
        
        # Tenta se conectar por at√© 2 minutos (12 * 10s)
        for i in {1..12}; do
          if curl -fs "http://$PUBLIC_IP" --connect-timeout 5; then
            echo "‚úÖ Application is responding!"
            exit 0
          fi
          echo "Attempt $i/12: Application not ready yet, waiting 10 seconds..."
          sleep 10
        done
        
        echo "‚ùå Application did not respond in time."
        exit 1